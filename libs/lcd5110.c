#include "main.h"
#include "lcd5110.h"

uint8_t pcd8544_buffer[84 * 48 / 8] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0x10, 0xF0, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x40, 0x40, 0x00, 0x40, 0x50, 0x51, 0x50, 0x50, 0x5C, 0x50,
0x20, 0x00, 0x40, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x84, 0x80, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFC, 0x00, 0x01, 0x00,
0x00, 0x88, 0x25, 0x21, 0x01, 0x01, 0x01, 0x01, 0x01, 0x05, 0x8D, 0x05, 0x00, 0x00, 0x20, 0x00,
0x00, 0x04, 0x9C, 0xFD, 0xFD, 0xF8, 0xF2, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x80,
0x20, 0x41, 0x52, 0xF2, 0x16, 0x14, 0x15, 0x14, 0x14, 0xE4, 0x84, 0x84, 0x84, 0x85, 0x05, 0xE4,
0x04, 0x04, 0xE4, 0x14, 0x14, 0x05, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x0F, 0x1F, 0x1D, 0x33, 0x24, 0x00, 0x0F, 0x0A, 0x4A, 0x4A, 0x40, 0x40, 0x4F, 0x40, 0x40,
0x40, 0x40, 0x40, 0x0F, 0x0A, 0x0A, 0x2F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};

uint8_t VBUF[84 * 48 / 8] = {
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    };

void LCDInit()
{
  gpioInit();
  SPI2Init();
  bltInit();
  RST_LOW;
  for(int i=0; i < 1000; i++){}
  RST_HIGH;
  lcd5110_setBias(0x04);
  lcd5110_setContrast(94);

  // normal mode
  lcd5110_command(PCD8544_FUNCTIONSET);

  // Set display to Normal
  lcd5110_command(PCD8544_DISPLAYCONTROL | PCD8544_DISPLAYNORMAL);
  lcd5110_display(pcd8544_buffer);
  delay_ms(1000);
}

void lcd5110_command(int data)
{
  DC_LOW;
  CS_LOW;
  SPI2->DR = data;
  while((SPI2->SR & SPI_SR_BSY) > 0){}
  CS_HIGH;
}

void lcd5110_data(uint8_t data)
{
  DC_HIGH;
  CS_LOW;
  SPI2->DR = data;
  while((SPI2->SR & SPI_SR_BSY) > 0){}
  CS_HIGH;
}

void lcd5110_setContrast(int val) 
{
  if (val > 0x7f) {
    val = 0x7f;
  }
  lcd5110_command(PCD8544_FUNCTIONSET | PCD8544_EXTENDEDINSTRUCTION );
  lcd5110_command( PCD8544_SETVOP | val);
  lcd5110_command(PCD8544_FUNCTIONSET);

 }


void lcd5110_setBias(int val) 
{
  if (val > 0x07) {
    val = 0x07;
  }
  lcd5110_command(PCD8544_FUNCTIONSET | PCD8544_EXTENDEDINSTRUCTION );
  lcd5110_command(PCD8544_SETBIAS | val);
  lcd5110_command(PCD8544_FUNCTIONSET);
}

void lcd5110_display(uint8_t* disp)
{
  //lcd5110_Clear();
  lcd5110_SetPos(0,0);
  for(uint8_t p = 0; p < 6; p++)
  {
    for(uint16_t col = 0; col <= 83; col++)
    {
      lcd5110_data(disp[(84*p) + col]);
    }
  }
}

void lcd5110_Clear()
{
  lcd5110_SetPos(0,0);
  for(uint8_t p = 0; p < 6; p++)
  {
    for(uint16_t col = 0; col <= 83; col++)
    {
      lcd5110_data(0);
    }
  }
}

void lcd5110_SetPos(uint8_t xPos, uint8_t yPos)
{
  lcd5110_command(PCD8544_SETYADDR | yPos);
  lcd5110_command(PCD8544_SETXADDR | xPos);
}

void gpioInit(){
  RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;// GPIOA clock enable
  RCC->APB2ENR |= RCC_APB2ENR_IOPBEN;// GPIOB clock enable
  GPIOB->CRL |= GPIO_CRL_MODE1_0 | GPIO_CRL_MODE1_1 |// D/C MODE CONFIG 11: Maximum output speed 50 MHz
                GPIO_CRL_MODE2_0 | GPIO_CRL_MODE2_1 ;// RST MODE CONFIG 11: Maximum output speed 50 MHz               
  GPIOB->CRH |= GPIO_CRH_MODE15_0 | GPIO_CRH_MODE15_1 |// MOSI MODE CONFIG 11: Maximum output speed 50 MHz
                GPIO_CRH_MODE12_0 | GPIO_CRH_MODE12_1 |// CHIP SELECT MODE CONFIG 11: Maximum output speed 50 MHz
                GPIO_CRH_MODE13_0 | GPIO_CRH_MODE13_1;// CLK MODE CONFIG 11: Maximum output speed 50 MHz
  GPIOB->CRL &= ~(GPIO_CRL_CNF1_0 | GPIO_CRL_CNF1_1);// D/C CNF CONFIG 00: GPIO Push-pull
  GPIOB->ODR |= GPIO_ODR_ODR1;// D/C SET TO HIGH
  GPIOB->CRL &= ~(GPIO_CRL_CNF2_0 | GPIO_CRL_CNF2_1);// RST CNF CONFIG 00: GPIO Push-pull
  GPIOB->ODR |= GPIO_ODR_ODR2;//RST SET TO HIGH
  GPIOB->CRH &= ~(GPIO_CRH_CNF12_0 | GPIO_CRH_CNF12_1);// CHIP SELECT CNF CONFIG 00: GPIO Push-pull
  GPIOB->ODR |= GPIO_ODR_ODR12;// CHIP SELECT SET TO LOW
  GPIOB->CRH &= ~GPIO_CRH_CNF15_0;//
  GPIOB->CRH |= GPIO_CRH_CNF15_1;// MOSI CNF CONFIG 10: AF Push-pull
  GPIOB->CRH &= ~GPIO_CRH_CNF13_0;//
  GPIOB->CRH |= GPIO_CRH_CNF13_1;// CLK CNF CONFIG 10: AF Push-pull
}

void SPI2Init(){
  RCC->APB1ENR |= RCC_APB1ENR_SPI2EN ;// SPI2 clock enable
  SPI2->CR1 = 1 << SPI_CR1_BIDIMODE_Pos
            | 1 << SPI_CR1_BIDIOE_Pos
            | 0 << SPI_CR1_DFF_Pos
            | 0 << SPI_CR1_RXONLY_Pos
            | 0 << SPI_CR1_LSBFIRST_Pos
          | 100 << SPI_CR1_BR_Pos// 011: fPCLK/16 72/16=4.5Mhz
            | 1 << SPI_CR1_SSM_Pos | 1 << SPI_CR1_SSI_Pos
            | 1 << SPI_CR1_CPOL_Pos
            | 1 << SPI_CR1_CPHA_Pos
            | 1 << SPI_CR1_MSTR_Pos
            | 1 << SPI_CR1_SPE_Pos;
}

void bltInit(){
  RCC->APB1ENR |= RCC_APB1ENR_TIM3EN; //1: Timer 3 clock enabled
  TIM3->CR1 &= ~TIM_CR1_CKD_0;//
  TIM3->CR1 &= ~TIM_CR1_CKD_1;//00: tDTS=tCK_INT
  TIM3->CR1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS_1 | TIM_CR1_CMS_0); //0: Counter used as upcounter
  TIM3->CR1 &= ~TIM_CR1_OPM; //0: Counter is not stopped at update event
  TIM3->ARR = 4096;
  TIM3->PSC = 6;
  TIM3->EGR |= TIM_EGR_UG; //1: Re-initialize the counter and generates an update of the registers. Note that the prescaler
                           //counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if
                           //the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload
                           //value (TIMx_ARR) if DIR=1 (downcounting).
  TIM3->CR1 &= ~TIM_CR1_ARPE; //0: TIMx_ARR register is notDIR: buffered
  TIM3->SMCR &= ~TIM_SMCR_SMS_0; // 
  TIM3->SMCR &= ~TIM_SMCR_SMS_1; // 
  TIM3->SMCR &= ~TIM_SMCR_SMS_2; // 000: Slave mode disabled - if CEN = ‘1’ then the prescaler is clocked directly by the internal clock
  TIM3->SMCR &= ~TIM_SMCR_ECE;//
  TIM3->CCMR2 &= ~TIM_CCMR2_OC3PE; //0: Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the new value is taken in account immediately
  TIM3->CCER |= TIM_CCER_CC3E; //0: Off - OC1 is not active. 
  TIM3->CCMR2 &= ~TIM_CCMR2_OC3M_0;//
  TIM3->CCMR2 |= TIM_CCMR2_OC3M_1 | TIM_CCMR2_OC3M_2;//110: PWM mode 1 - In upcounting, channel 1 is active as long as TIMx_CNT<TIMx_CCR1 else inactive. In downcounting, channel 1 is inactive (OC1REF=‘0’) as long as TIMx_CNT>TIMx_CCR1 else active (OC1REF=’1’).
  TIM3->CCMR2 &= ~(TIM_CCMR2_CC3S_0 | TIM_CCMR2_CC3S_1); //00: CC1 channel is configured as output
  TIM3->CCER &= ~TIM_CCER_CC3P; //0: OC1 active high
  TIM3->CCR3 = 0;
  TIM3->CCMR2 &= ~TIM_CCMR2_OC3FE; //Output compare 1 fast enable
                                   //This bit is used to accelerate the effect of an event on the trigger in input on the CC output.
                                   //0: CC1 behaves normally depending on counter and CCR1 values even when the trigger is
                                   //ON. The minimum delay to activate CC1 output when an edge occurs on the trigger input is
                                   //5 clock cycles.
  TIM3->CR2 &= ~TIM_CR2_MMS_0; //000: Reset 
  TIM3->CR2 &= ~TIM_CR2_MMS_1; //000: Reset 
  TIM3->CR2 &= ~TIM_CR2_MMS_2; //000: Reset 
  TIM3->SMCR &= ~TIM_SMCR_MSM; //Master/Slave mode 0: No action
  RCC->APB2ENR |= RCC_APB2ENR_IOPBEN;
  GPIOB->CRL &= ~GPIO_CRL_CNF0_0;//
  GPIOB->CRL |= GPIO_CRL_CNF0_1;//10: AF Push-pull
  GPIOB->CRL |= GPIO_CRL_MODE0_0 | GPIO_CRL_MODE0_1 ;//11: Maximum output speed 50 MHz
  TIM3->CR1 |= TIM_CR1_CEN;//1: Counter enabled
}